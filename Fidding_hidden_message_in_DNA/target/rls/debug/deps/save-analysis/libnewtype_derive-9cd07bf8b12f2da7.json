{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.1","compilation":{"directory":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6","program":"/Users/shelwitz/.rustup/toolchains/stable-x86_64-apple-darwin/bin/rls","arguments":["--crate-name","newtype_derive","/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","embed-bitcode=no","-C","split-debuginfo=unpacked","-C","debuginfo=2","--cfg","feature=\"default\"","--cfg","feature=\"std\"","-C","metadata=9cd07bf8b12f2da7","-C","extra-filename=-9cd07bf8b12f2da7","--out-dir","/Users/shelwitz/Bioinfo/Coursera_Bioinfo/Fidding_Hidden_MessageInDNA/practice/target/rls/debug/deps","-L","dependency=/Users/shelwitz/Bioinfo/Coursera_Bioinfo/Fidding_Hidden_MessageInDNA/practice/target/rls/debug/deps","--cap-lints","allow","--cfg","op_assign","--error-format=json","--sysroot","/Users/shelwitz/.rustup/toolchains/stable-x86_64-apple-darwin"],"output":"/Users/shelwitz/Bioinfo/Coursera_Bioinfo/Fidding_Hidden_MessageInDNA/practice/target/rls/debug/deps/libnewtype_derive-9cd07bf8b12f2da7.rmeta"},"prelude":{"crate_id":{"name":"newtype_derive","disambiguator":[5705877678033399939,2816303940852188445]},"crate_root":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src","external_crates":[{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[7439535968655576646,17420488833649705410]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[1949116827220114676,2065912148165510692]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[6424123809251651324,10791243255933316672]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[11089070161906179638,2253832597208660558]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[3666879193032761931,4629784602926728112]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[17557414160303111626,7572947572632644954]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[915848953387719454,11341216537588130533]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[4285064400235759547,17176111531075018758]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":9,"id":{"name":"hashbrown","disambiguator":[6997063163517280748,14486342634155193831]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":10,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[2053070849310045891,9457326657766539472]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":11,"id":{"name":"rustc_demangle","disambiguator":[16492367081693084488,12081229032515817188]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":12,"id":{"name":"std_detect","disambiguator":[14000704685499991975,15439018228330051001]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":13,"id":{"name":"addr2line","disambiguator":[16882152814081891816,2081400005890767566]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":14,"id":{"name":"gimli","disambiguator":[17412809486977561704,10774188040798205111]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":15,"id":{"name":"object","disambiguator":[10299009701328497764,8719717191227013711]}},{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","num":16,"id":{"name":"panic_unwind","disambiguator":[13564088873543153286,4566579444635585591]}}],"span":{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","byte_start":382,"byte_end":35907,"line_start":10,"line_end":1171,"column_start":1,"column_end":2}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","byte_start":382,"byte_end":35907,"line_start":10,"line_end":1171,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2}],"decl_id":null,"docs":"This crate provides several macros for deriving implementations of various traits for \"newtype\" wrappers (*i.e.* tuple structs with a single element).  That is, given a tuple struct with exactly one field (*e.g.* `struct Buckets(i32)`), these macros will derive \"obvious\" implementations of traits such as `Add`, `Neg`, `Index`, `Deref`, `From`, etc.","sig":null,"attributes":[{"value":"*\nThis crate provides several macros for deriving implementations of various traits for \"newtype\" wrappers (*i.e.* tuple structs with a single element).  That is, given a tuple struct with exactly one field (*e.g.* `struct Buckets(i32)`), these macros will derive \"obvious\" implementations of traits such as `Add`, `Neg`, `Index`, `Deref`, `From`, etc.\n\nAll of these macros are designed to be used with the [`custom_derive`](https://crates.io/crates/custom_derive) crate, though they can be used independent of it.\n\n# Example\n\nCreate a simple integer wrapper with some arithmetic operators:\n\n```rust\n#[macro_use] extern crate custom_derive;\n#[macro_use] extern crate newtype_derive;\n\ncustom_derive! {\n    #[derive(NewtypeFrom, NewtypeAdd, NewtypeMul(i32))]\n    pub struct Happy(i32);\n}\n\n# fn main() {\n// Let's add some happy little ints.\nlet a = Happy::from(6);\nlet b = Happy::from(7);\nlet c = (a + b) * 3;\nlet d: i32 = c.into();\nassert_eq!(d, 39);\n# }\n```\n\nCreate a \"deref-transparent\" wrapper around a type:\n\n```rust\n#[macro_use] extern crate custom_derive;\n#[macro_use] extern crate newtype_derive;\n\ncustom_derive! {\n    #[derive(NewtypeFrom,\n        NewtypeDeref, NewtypeDerefMut,\n        NewtypeIndex(usize), NewtypeIndexMut(usize)\n        )]\n    pub struct I32Array(Vec<i32>);\n}\n\n# fn main() {\nlet mut arr = I32Array::from(vec![1, 2, 3]);\narr.push(4);\narr[2] = 5;\nassert_eq!(&**arr, &[1, 2, 5, 4]);\nassert_eq!(arr.len(), 4);\n# }\n```\n\n# Overview\n\nThis crate provides macros to derive implementations of the following traits for newtype structs:\n\n- Binary Arithmetic Operators: Add, BitAnd, BitOr, BitXor, Div, Mul, Rem, Sub, Shl, Shr, plus the corresponding *Assign traits.\n- Unary Arithmetic Operators: Neg, Not.\n- Other Operators: Deref, DerefMut, Index, IndexMut.\n- Formatting: Binary, Debug, Display, LowerExp, LowerHex, Octal, Pointer, UpperExp, UpperHex.\n- Miscellaneous: From.\n- Unstable: One, Product, Sum, Zero (requires the `std-unstable` feature).\n\nAll of these macros are named `Newtype$Trait`.\n\nNone of these macros currently support generic newtype structs.\n\n## Binary Arithmetic Operators\n\nEach of the binary arithmetic operators accept several deriving forms.  To use `Add` on a struct `T` as an example:\n\n- `NewtypeAdd`: `impl Add<T, Output=T> for T`\n- `NewtypeAdd(&self)`: `impl<'a> Add<&'a T, Output=T> for &'a T`\n- `NewtypeAdd(U)`: `impl Add<U, Output=T> for T`\n- `NewtypeAdd(&self, U)`: `impl<'a> Add<U, Output=T> for &'a T`\n- `NewtypeAdd(*)`: All four combinations of `T` and `&T`\n\nThe `*Assign` variants accept zero or one argument only.  For example:\n\n- `NewtypeAddAssign`: `impl AddAssign<T> for T`\n- `NewtypeAddAssign(&Self)`: `impl<'a> Add<&'a T> for &'a T`\n- `NewtypeAddAssign(U)`: `impl Add<U> for T`\n- `NewtypeAddAssign(*)`: Implements for `T` and `&T`.\n\nIn all cases, the implementation unwraps the newtype (where necessary), forwards to the wrapped value's implementation, then re-wraps the result in the newtype.\n\n## Unary Arithmetic Operators\n\nEach of the binary arithmetic operators accept several deriving forms.  To use `Neg` on a struct `T` as an example:\n\n- `NewtypeNeg`: `impl Neg<Output=T> for T`\n- `NewtypeNeg(&self)`: `impl<'a> Neg<Output=T> for &'a T`\n- `NewtypeNeg(*)`: both of the above\n\nIn all cases, the implementation unwraps the newtype, forwards to the wrapped value's implementation, then re-wraps the result in the newtype.\n\n## Other Operators\n\n`NewtypeDeref` and `NewtypeDerefMut` only support the argument-less form, and implements the corresponding trait such that the newtype structure derefs to a pointer to the wrapped value.\n\n`NewtypeIndex` and `NewtypeIndexMut` must be used as `NewtypeIndex(usize)`, where the argument is the type to use for indexing.  The call is forwarded to the wrapped value's implementation.\n\n## Formatting\n\nThe deriving macros for the formatting traits in [`std::fmt`][] forward to the wrapped value's implementation.\n\n[`std::fmt`]: http://doc.rust-lang.org/std/fmt/index.html\n\n## Miscellaneous\n\n`NewtypeFrom` implements `std::convert::From` twice: once for converting from the wrapped type to the newtype, and once for converting from the newtype to the wrapped type.\n\n`NewtypeProduct` and `NewtypeSum` optionally support specifying `&Self` as an argument to generate an implementation that accepts an iterator of borrowed pointers (*e.g.* `NewtypeSum(&Self)`).\n\n## Using Without `custom_derive!`\n\nAlthough designed to be used with `custom_derive!`, all of the macros in this crate can be used without it.  The following:\n\n```rust\n# #[macro_use] extern crate custom_derive;\n# #[macro_use] extern crate newtype_derive;\ncustom_derive! {\n    #[derive(Copy, Clone, Debug, NewtypeFrom, NewtypeAdd, NewtypeAdd(f32))]\n    pub struct Meters(f32);\n}\n# fn main() {}\n```\n\nCan also be written as:\n\n```rust\n# #[macro_use] extern crate newtype_derive;\n#[derive(Copy, Clone, Debug)]\npub struct Meters(f32);\n\nNewtypeFrom! { () pub struct Meters(f32); }\nNewtypeAdd! { () pub struct Meters(f32); }\nNewtypeAdd! { (f32) pub struct Meters(f32); }\n# fn main() {}\n```\n*/","span":{"file_name":"/Users/shelwitz/.cargo/registry/src/github.com-1ecc6299db9ec823/newtype_derive-0.1.6/src/lib.rs","byte_start":382,"byte_end":5422,"line_start":10,"line_end":149,"column_start":1,"column_end":3}}]}],"impls":[],"refs":[],"macro_refs":[],"relations":[]}